1.JSON ?

-- JSON stands for JavaScript Object Notation & we import the JSON package in Python script
-- It is used for storing and transferring data between browser and server
-- In JSON the text will be in double quotes as key-value pair within { }, it is similar to dictionary in Python
-- JSON Syntax - {"key":"value"}
-- JSON supports primitive types like strings and numbers, as well as nested lists, tuples, and objects 



-- Serializing/Encoding JSON(dump )? 

-- The process of encoding JSON is called serialization

    (1)To Convert from dictionary to JSON  -- json.dumps() method is used 
       Syntax : json.dumps(dict, indent)
	   
	(2)For Writing JSON to a file  --  json.dump() method is used
       Syntax : json.dump(dict, file_object, indent)

   
   
-- Deserializing/Decoding JSON(load)? 

-- The process of decoding JSON is called deserialization

   (1)To Convert from JSON to Python  --  json.loads() method is used
      Syntax : json.loads(json_string)
	  
   (2)To read JSON file  --  json.load() method is used
      Syntax : json.load(file_object)



-- Append / update(): This method updates the dictionary with elements from another dictionary object
	 Syntax : dict.update([other])
	 
	 
	 
2.File Handling?

-- Python supports file handling and allows users to read and write files
-- Each line of a file is terminated with a special character called EOL {,}

-- Working of open() : Before performing any operation on the file like read or write, we have to use Python inbuilt function open() to open the file
   Synatax : f = open(filename, mode)
   
-- There are different modes to perform the operations like:

    r: open an existing file for a read operation.
	Syntax : file = open("file.text", "r")
             print (file.read())
			 
    w: open an existing file for a write operation, if the file already contains data then it will be overridden. 
	Syntax : file = open("file.txt","w")
             print(file.write())
             file.close()
			 
    a: open an existing file for append operation, it won’t override existing data.
	Syntax : file = open("file.txt","a")
             print(file.write())
             file.close()
			 
   r+: To read and write data into the file, the previous data in the file will not be deleted.
   Syntax : file = open("file.txt","r+")
             print(file.write())
             file.close()
			 
   w+: To write and read data, it will override existing data.
   Syntax : file = open("file.txt","w+")
             print(file.write())
             file.close()
			 
   a+: To append and read data from the file, it won’t override existing data. 
   Syntax : file = open("file.txt","a+")
             print(file.write())
             file.close()

-- Using write along with the with() function:
   Syntax : with open("file.txt", "w") as f:
            print(f.write())
			

-- split() function using file handling: 
   We can also split lines using file handling
   Syntax : with open("file.text", "r") as file:
            data = file.readlines()
            for line in data:
            word = line.split()
            print(word)
			
			

3.Subprocess Module?

-- It is used to run new applications or programs through Python code by creating new process.
-- Popen() method is used to give the command and we will get the output.
-- It helps to obtain the stdin/stdout/stderr/return code as well as the exist codes of various commands
-- syntax: output = subprocess.run("ping www.google.com", stdout=subprocess.PIPE, encoding="utf-8", shell=True)
-- We have run method in subprocess:
   - First argument is input/command
   - Second argument is output of the command
   - Third argument is Encoding (bytes to string)
   - Next it will check the shell(as python program to execute this command on command prompt)
   - It will check whether it is stdout/stderr /return code 
   - return always should be non-zero, it means command executed successfully.
   
   
   
4. GITHUB?

-- GitHub is a code hosting platform for collaboration and helps us to work with others on projects

-- GitHub essentials are:

   - Repositories
   - Branches
   - Commits
   - Pull Requests/Merge Requests
   
   
-- Repositories:
   - It is used to store code/files to push/maintain/publish/review/pull code.  
   - It contain folders and any type of files like HTML, CSS, JavaScript, Documents, Data, Images
   
-- Branches:
   - A GitHub branch is used to work with different versions of a repository at the same time.
   - By default a repository has a master branch
   - Any other branch is a copy of the master branch
   - New Branches are for bug fixes and feature work separate from the master branch. 
   - When changes are ready, they can be merged into the master branch. 
   - If you make changes to the master branch while working on a new branch, these updates can be pulled in. 

-- Commits:
   - At GitHub, changes are called commits.
   - Each commit/changes has an explaination why a change was made.
   
-- Pull Requests/Merge Requests:
   - Pull Requests are the heart of GitHub collaboration.
   - With a pull request your changes will be merged (pulled in) with the master.
   - Pull requests show content differences, changes, additions, and subtractions in colors (green and red).
   - As soon as you have a commit, you can open a pull request and start a discussion, even before the code is finished.   
   
-- Process in usage of GIT: 
  
   - git clone -It is used for downloading the code for first time
   - git pull origin main - It is used to get the added files/code 
   
***** To do any changes: 

   - git branch branch_name - We need to enter the repository name
   - git diff - It shows the difference
   - git status - It shows the difference
   - git add . - Adding your changed files
   - git commit -m "Date_"
   - git push origin branch_name



5. PIP?

-- PIP is a Python Installation Packager 
-- We can use pip to install packages that do not come with Python.
  
-- What is a Package?
   - A package contains all the files you need for a module.
   - Modules are Python code libraries you can include in your project.   
   
-- How to install pip?
   - In Python pip comes pre-installed on 3.4 or older versions of Python.
   - To check whether pip is installed or not type the below command in the terminal.
    pip --version
	
-- Download a Package:
   - Open the command prompt and tell PIP to download the package you want.

   - Example
    Download a package named "camelcase":
    C:\Users\Your Name\AppData\Local\Programs\Python\Python36-32\Scripts>pip install camelcase	
	Now you have downloaded and installed your package
	
-- Using a Package
   - Once the package is installed
   - Import the "camelcase" package into your project.

-- Remove a Package:
   - Use the uninstall command to remove a package
   
-- List Packages:
   - Use the list command to list all the packages installed on your system   
   
   
   
6. Type Casting?
 
-- The method to convert the variable data type into a certain data type in order to the operation required to be performed by users
-- There can be two types of Type Casting in Python:
   - Implicit Type Casting
   - Explicit Type Casting
   
-- Implicit Type Casting:
   - Python converts data type into another data type automatically without involving users 
   - Example:
		a = 7
		print(type(a))
 
		b = 3.0
		print(type(b))
 
		O/P:
		<class 'int'>
		<class 'float'>
		
-- Explicit Type Casting:
   - In this method, Python need user involvement to convert the variable data type into certain data type
   - Type casting can be done with these data type function:

		- int() : int() function take float or string as an argument and return int type object.
		- float() : float() function take int or string as an argument and return float type object.
		- str() : str() function take float or int as an argument and return string type object.

-- Let’s see some example of type casting:				
   - Type Casting int to float:							- Type Casting int to string				
		a = 5												a = 5
		n= float(a)											n = str(a)
		print(n)											print(n)
		print(type(n))										print(type(n))
		O/P:5.0												O/P: '5'
			<class 'float'>		 							   <class 'str'>
		

   
7. Pylint module?

-- pylint module provides tips to get a good score on my code
-- While we run code/some programs we encounter errors, if there are no comments/docstrings in the code
-- Pylint is a tool that

	- Lists Errors which comes after execution of that Python code
	- Enforces a coding standard and looks for code smells
	- Suggest how particular blocks can be updated
	- Offer details about the code’s complexity
	
-- some techniques to improve score	:

	- Minimizing white space error
	- Reducng missing-new-line suggestion
	- Minimizing missing-module-docstring suggestion
	- To avoid invalid-name suggestion 
	
	
	
8. Logging Module?

-- Logging is the process of tracking work happen when some software runs	
-- It is for software developing, debugging and running
-- If we don't have log record & if data is lost it takes time to detect the issue
-- If we have log file record if something goes wrong, we can find the issue

-- Why Printing is not a good option?
	--Some developers used to printing the statements to validate if the statements are executed correctly or not. 
	-- It may solve your issues for simple scripts but for complex scripts, printing approach will fail
	
-- built-in levels of log message:
    Debug : This is used for Detail information, whenever required to diagnoise problems.
	Info : These are used to Confirm that things are working as expected
	Warning : It gives an indication if something unexpected happened, whether there is any problem in future
	Error : It tells us about serious problem, if the software is not able to perform some function
	Critical : This tells serious error, indicating that the program itself may be unable to continue running
	
	
	
9. Random Module?

-- Random module is an in-built module of Python which is used to generate random numbers. 
-- This module used to perform random actions such as generating random numbers, print random a value for a list or string, etc

-- Example: import random
			list1 = [1, 2, 3, 4, 5, 6]
			print(random.choice(list1))

				O/P: 
				
-- randrange() in Python:
	A function that generate random numbers from a given range and steps to be included, called randrange() 
	Syntax : random.randrange(start,stop,step)	
				
-- Creating Random Integers:
	random.randint() method is used to generate random integers between the given range.
	Syntax : random.randint(start, end)	
	
-- Creating Random Floats:
	random.random() method is used to generate random integers between 0.0 to 1.
	Syntax: random.random()
		
-- Selecting Random Choice:
	random.choice() function is used to return a random item from a list, tuple, or string.
	Syntax: random.choice(sequence)		
						
-- Shuffling List:
	random.shuffle() method is used to shuffle a sequence (list).
	Syntax: random.shuffle(sequence, function)



10. Winrm?

-- Winrm stands for Windows Remote Management
-- It allows us to run commands on target Windows machines from any machine that can run Python. 
-- It allows us to perform various management tasks remotely.
-- To install winrm - pip install pywinrm

import winrm
prot=winrm.protocol.protocol
			(endpoint="http://2019A:5985/wsman",
			transport="ntlm",
			username="username@gmail.com",
			password="password"
			server_cert_validation="ignore")
			
shell=prot.open_shell()
command=prot.run_command(shell,"ipconfig")
out,err,status=prot.get_command_output(shell,command)
print(f"errors :{err}")
print(f"status : {status}")
print(f"output : {out}")




11.Paramiko?

-- To transfer a file from local server to remote server & vice-versa using paramiko module in python
-- On windows to install paramiko use , pip install paramiko in command prompt
-- SSH is the method typically used to access a remote machine and run commands, retrieve files or upload files.
-- You can transfer files using SFTP (Secure File Transfer Protocol) and SCP(Secure Copy Protocol).
-- MAKING A CONNECTION : 
		import paramiko
		ssh_client=paramiko.SSHClient()
		ssh_client.connect(hostname=’hostname’,username=’username’,password=’mypassword’,port='')

-- Downloading a file from remote machine

		sftp_client=ssh_client.open_sftp()
		sftp_client.get(‘remotefileth’,’localfilepath’)
		sftp_client.close()
		
		
-- Uploading file from local to remote machine
		sftp_client=ssh_client.open_sftp()
		sftp_client.put(‘localfilepath’,remotefilepath’)
		sftp_client.close()





12.Lambda Expression?
-- It is an anonymous function/function having no name.
-- This function can have multiple arguments but only one expression, we get as output
-- syntax : lambda arguments: expression
-- Example: input=lambda n:n+n
			result=input(50)
			print(result)

-- Without using Lambda: while using def, we needed to define a function and need to pass a value to it.
   -- After execution, we also needed to return the result from where the function was called using the return keyword.
 
-- Using Lambda: Lambda function doesn't need “return” statement, it always contains an expression that is returned. 
	We can use lambda definition anywhere a function is expected, and we don’t have to assign it to a variable 

-- lambda supports 3 functions like: filter(), map(), reduce()

-- filter() :filter() function takes all the elements in the list as arguments and it filter all the elements of a sequence
				for which the function returns True

			Example:num_1=[1,3,5,6,8,23,22,56,12,69,33,31]
			even_num=list(filter(lambda n :n%2==0,num_1))
			print(even_num)


-- map() : The map() function takes all the elements in the list as arguments and it map each element of a sequence and returns the new list

			Example:num_1=[1,3,5,6,8,23,22,56,12,69,33,31] # map() is used to map all the values in the list
			double =list(map(lambda n :n*2,num_1))
			print(double)


-- reduce(): while using reduce method we need to import it from functools
			The reduce() function takes all the elements in the list as arguments and it performs a repetitive operation over the pairs of the iterable and new reduced result is returned

			Example:from functools import reduce

					num_1=[1,3,5,6,8,23,22,56,12,69,33,31] # reduce() is used to map all the values in the list
					total_sum =reduce(lambda a,b:a+b,num_1)
					print(total_sum)


	
	
13. Multi-Threading?

-- It is defined as the ability of a processor to execute multiple threads concurrently.








14. Windows Commands

-- command prompt is a powerful Windows tool, there are most useful CMD commands every Windows user need to know

1. Assoc:
-- Mostly files in Windows are associated with a specific program that is assigned to open the file by default. By entering the command assoc to display a full list of filename extensions and program associations.

2. Cipher:
-- Deleting files on a mechanical hard drive doesn't really delete them at all. Instead, it marks the files as no longer accessible and the space they took up as free. The files remain recoverable until the system overwrites them with new data

3. Driverquery:
-- Drivers remain among the most important software installed on a PC. Improperly configured, missing, or old drivers in Windows can cause all sorts of trouble, so it's good to have access to a list of what's on your PC.You can extend it to driverquery -v to obtain more information, including the directory in which the driver is installed.

4. File Compare:
-- You can use this command to identify differences in text between two files. It's particularly useful for writers and programmers trying to find small changes between two versions of a file. Simply type fc and then the directory path and file name of the two files you want to compare.

5. ipconfig:
-- This command relays the IP address that your computer is currently using. However, if you're behind a router (like most computers today), you'll instead receive the local network address of the router.ipconfig is useful because of its extensions

6. Netstat:
-- Entering the command netstat -an will provide you with a list of currently open ports and related IP addresses. This command will also tell you what state the port is in; listening, established, or closed

7. Ping:
-- Typing ping followed by an IP address or web domain will send a series of test packets to the specified address. If they arrive and are returned, you know the device is capable of communicating with your PC; if it fails, you know that there's something blocking communication between the device and your computer.

8. Pathping:
-- Typing ping followed by an IP address or web domain will send a series of test packets to the specified address. If they arrive and are returned, you know the device is capable of communicating with your PC; if it fails, you know that there's something blocking communication between the device and your computer.

9. Tracert:
-- he tracert command is similar to pathping. Once again, type tracert followed by the IP address or domain you'd like to trace. You'll receive information about each step in the route between your PC and the target. Unlike pathping, however, tracert also tracks how much time (in milliseconds) each hop between servers or devices takes

10. Powercfg:
-- Powercfg is a very powerful command for managing and tracking how your computer uses energy. You can use the command powercfg hibernate on and powercfg hibernate off to manage hibernation, and you can also use the command powercfg /a to view the power-saving states currently available on your PC

11. Systeminfo:
--This command will give you a detailed configuration overview of your computer. The list covers your operating system and hardware. For example, you can look up the original Windows installation date, the last boot time, your BIOS version, total and available memory, installed hotfixes, network card configurations, and more.

12. System File Checker:
-- You will need to run the command prompt with administrator privileges and enter the command sfc /scannow. If SFC finds any corrupt or missing files, it will automatically replace them using cached copies kept by Windows for this purpose alone. 

13. Tasklist:
-- You can use the tasklist command to provide a current list of all tasks running on your PC.Tasklist -svc shows services related to each task, use tasklist -v to obtain more detail on each task, and tasklist -m will locate DLL files associated with active tasks.





15. Linux Commands?

pwd 		:The pwd command is used to display the location of the current working directory

mkdir 		:He mkdir command is used to create a new directory under any directory.

rmdir 		:The rmdir command is used to delete a directory.

ls			:The ls command is used to display a list of content of a directory.

cd 			:The cd command is used to change the current directory

touch		:The touch command is used to create empty files. We can create multiple empty files by executing it once.

cat			:The cat command is a multi-purpose utility in the Linux system. 
			It can be used to create a file, display content of the file, copy the content of one file to another file, and more.
			
rm			:The rm command is used to remove a file.

cp			:The cp command is used to copy a file or directory

mv			:The mv command is used to move a file or a directory form one location to another locatio

rename		:The rename command is used to rename files. It is useful for renaming a large group of files.

head		:The head command is used to display the content of a file. It displays the first 10 lines of a fil

tail		:The tail command is similar to the head command. The difference between both commands is that it displays the last ten lines of the file content. It is useful for reading the error message.

tac			:The tac command is the reverse of cat command, as its name specified. It displays the file content in reverse order (from the last line).

more		:The more command is quite similar to the cat command, as it is used to display the file content in the same way that the cat command does. The only difference between both commands is that, in case of larger files, the more command displays screenful output at a time.

less		:The less command is similar to the more command. It also includes some extra features such as 'adjustment in width and height of the terminal.' Comparatively, the more command cuts the output in the width of the terminal.

su			:The su command provides administrative access to another user. In other words, it allows access of the Linux shell to another user.

id			:The id command is used to display the user ID (UID) and group ID (GID).

useradd		:The useradd command is used to add or remove a user on a Linux server.

passwd		:The passwd command is used to create and change the password for a user.












                                                                Os module

OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using 
operating system-dependent functionality. The *os* and *os.path* modules include many functions to interact with the file system.

1)Handling the Current Working Directory:-
To get the location of the current working directory os.getcwd() is used.

import os
     
# Get the current working directory (CWD)
cwd = os.getcwd()
     
# Print the current working directory (CWD)
print("Current working directory:", cwd)
-------------------------------------------------------------------------------------------------------

2)Changing the Current working directory:-

To change the current working directory(CWD) os.chdir() method is used. This method changes the CWD to a specified path. It only takes a single argument as a new directory path.
 import os
   
# Function to Get the current working directory
def current_path():
    print("Current working directory before")
    print(os.getcwd())
    print()
   
   
# Driver's code Printing CWD before
current_path()
   
# Changing the CWD
os.chdir('../')
   
# Printing CWD after
current_path()
--------------------------------------------------------------------------------------------------------------

3)Creating a Directory:-
There are different methods available in the OS module for creating a directory. These are –

os.mkdir()
os.makedirs()

Using os.mkdir():---------
os.mkdir() method in Python is used to create a directory named path with the specified numeric mode. This method raises FileExistsError if the directory to be created already exists.


import os
 
# Directory
directory = "mahesh"
 
# Parent Directory path
parent_dir = " "
 
# Path
path = os.path.join(parent_dir, directory)
 
# Create the directory "mahesh" in '/home / User / Documents'
os.mkdir(path)
print("Directory '% s' created" % directory)
 
# Directory
directory = "mahi.txt"
 
# Parent Directory path
parent_dir = "D:/Pycharm projects"
 
# mode
mode = 0o666
 
# Path
path = os.path.join(parent_dir, directory)
 
# Create the directory "mahesh" in '/home / User / Documents' with mode 0o666
os.mkdir(path, mode)
print("Directory '% s' created" % directory)

Using os.makedirs():--------
os.makedirs() method in Python is used to create a directory recursively. That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() 
method will create them all.

import os
     
# Leaf directory
directory = "mahesh.personal"
     
# Parent Directories
parent_dir = "D:/Pycharm projects/GeeksForGeeks/Authors"
     
# Path
path = os.path.join(parent_dir, directory)
     
# Create the directory "mahesh.personal"
os.makedirs(path)
print("Directory '% s' created" % directory)
     

# Leaf directory
directory = "important"
     
# Parent Directories
parent_dir = "D:/Pycharm projects/GeeksforGeeks/a/b"
     
# mode
mode = 0o666
     
path = os.path.join(parent_dir, directory)
     
# Create the directory 'c'
     
os.makedirs(path, mode)
print("Directory '% s' created" % directory)

------------------------------------------------------------------------------------------------------------

4)Listing out Files and Directories with Python:--
os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then the list of files
and directories in the current working directory will be returned.

import os
 
# Get the list of all files and directories in the root directory
path = "/"
dir_list = os.listdir(path)
 
print("Files and directories in '", path, "' :")
 
# print the list
print(dir_list)
 
----------------------------------------------------------------------------------------------------------------
5)Deleting Directory or Files using Python:-
OS module proves different methods for removing directories and files in Python. These are – 

Using os.remove()
Using os.rmdir()

Using os.remove()
os.remove() method in Python is used to remove or delete a file path. This method can not remove or delete a directory. If the specified path is a directory then OSError will 
be raised by the method.

import os
     
# File name
file = 'file1.txt'
     
# File location
location = "D:/Pycharm projects/mahesh/mahesh.personal/"
     
# Path
path = os.path.join(location, file)
     
# Remove the file 'file.txt'
os.remove(path)


Using os.rmdir()
os.rmdir() method in Python is used to remove or delete an empty directory. OSError will be raised if the specified path is not an empty directory.

import os
     
# Directory name
directory = "Geeks"
     
# Parent Directory
parent = "D:/Pycharm projects/"
     
# Path
path = os.path.join(parent, directory)
     
# Remove the Directory "mahi.txt"
os.rmdir(path)

-------------------------------------------------------------------------------------------------------------

6)Commonly Used Functions
1.os.name: This function gives the name of the operating system dependent module imported. The following names have currently been registered: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’ 
and ‘riscos’.

import os
 
print(os.name)

2.os.error: All functions in this module raise OSError in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type, but are not 
accepted by the operating system. os.error is an alias for built-in OSError exception. 

import os
 
 
try:
    # If the file does not exist,then it would throw an IOError
    filename = 'GFG.txt'
    f = open(filename, 'rU')
    text = f.read()
    f.close()
 
# Control jumps directly to here if any of the above lines throws IOError.   
except IOError:
 
    # print(os.error) will <class 'OSError'>
    print('Problem reading: ' + filename)

3.os.popen(): This method opens a pipe to or from command. The return value can be read or written depending on whether the mode is ‘r’ or ‘w’.

import os
fd = "GFG.txt"
 
# popen() is similar to open()
file = open(fd, 'w')
file.write("Hello")
file.close()
file = open(fd, 'r')
text = file.read()
print(text)
 
# popen() provides a pipe/gateway and accesses the file directly
file = os.popen(fd, 'w')
file.write("Hello")
# File not closed, shown in next function.

4. os.close(): Close file descriptor fd. A file opened using open(), can be closed by close()only. But file opened through os.popen(), can be closed with close() or os.close(). 
If we try closing a file opened with open(), using os.close(), Python would throw TypeError. 

import os
 
fd = "GFG.txt"
file = open(fd, 'r')
text = file.read()
print(text)
os.close(file)

5. os.rename(): A file old.txt can be renamed to new.txt, using the function os.rename(). The name of the file changes only if, the file exists and the user has sufficient privilege 
permission to change the file.

import os
 
fd = "GFG.txt"
os.rename(fd,'New.txt')

6. os.remove(): Using the Os module we can remove a file in our system using the remove() method. To remove a file we need to pass the name of the file as a parameter. 

import os #importing os module.
 
os.remove("file_name.txt") #removing the file.

7. os.path.exists(): This method will check whether a file exists or not by passing the name of the file as a parameter. OS module has a sub-module named PATH by using which we 
can perform many more functions. 

import os
#importing os module
 
result = os.path.exists("file_name") #giving the name of the file as a parameter.
 
print(result)

8. os.path.getsize(): In this method, python will give us the size of the file in bytes. To use this method we need to pass the name of the file as a parameter.

import os #importing os module
 
size = os.path.getsize("filename")
 
print("Size of the file is", size," bytes.")

____________________________________________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________________________________________________
                                                               
															   Datetime module

In Python, date and time are not a data type of their own, but a module named datetime can be imported to work with the date as well as time. Python Datetime module comes built 
into Python, so there is no need to install it externally.

The DateTime module is categorized into 6 main classes – 

date – An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Its attributes are year, month and day.
time – An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. Its attributes are hour, minute, second, microsecond, and tzinfo.
datetime – Its a combination of date and time along with the attributes year, month, day, hour, minute, second, microsecond, and tzinfo.
timedelta – A duration expressing the difference between two date, time, or datetime instances to microsecond resolution.
tzinfo – It provides time zone information objects.
timezone – A class that implements the tzinfo abstract base class as a fixed offset from the UTC.						
-------------------------------------------------------------------------------------------------------------------------
1)Date class:--
The date class is used to instantiate date objects in Python. When an object of this class is instantiated, it represents a date in the format YYYY-MM-DD. Constructor of this class 
needs three mandatory arguments year, month and date.


from datetime import date
 

my_date = date(1996, 12, 11)
 
print("Date passed as argument is", my_date)

------------------------------------------------------------------------------------------------------------------------
2)Get Current Date:--
To return the current local date today() function of date class is used. today() function comes with several attributes (year, month and day). These can be printed individually. 

# Python program to print current date
 
from datetime import date

today = date.today()
 
print("Today's date is", today)
------------------------------------------------------------------------------------------------------------------------

3)Get Today’s Year, Month, and Date:--
We can get the year, month, and date attributes from the date object using the year, month and date attribute of the date class.

from datetime import date
 
# date object of today's date
today = date.today()
 
print("Current year:", today.year)
print("Current month:", today.month)
print("Current day:", today.day)
------------------------------------------------------------------------------------------------------------------------

4)Get date from Timestamp:--
We can create date objects from timestamps y=using the fromtimestamp() method. The timestamp is the number of seconds from 1st January 1970 at UTC to a particular date.

from datetime import datetime
 
# Getting Datetime from timestamp
date_time = datetime.fromtimestamp(1887639468)
print("Datetime from timestamp:", date_time)
---------------------------------------------------------------------------------------------------------------------------
5)Convert Date to String:--
We can convert date object to a string representation using two functions isoformat() and strftime().

from datetime import date
   
# calling the today function of date class
today = date.today()
   
# Converting the date to the string
Str = date.isoformat(today)
print("String Representation", Str)
print(type(Str))
------------------------------------------------------------------------------------------------------------------------------

Time class:--
The time class creates the time object which represents local time, independent of any day. 

1)Time object representing time in Python

# Python program to demonstrate time class
 
from datetime import time
 
# calling the constructor
my_time = time(13, 24, 56)
 
print("Entered time", my_time)
 
# calling constructor with 1 argument
my_time = time(minute=12)
print("\nTime with one argument", my_time)
 
# Calling constructor with 0 argument
my_time = time()
print("\nTime without argument", my_time)
-----------------------------------------------------------------------------------------------------------------------------
2)Get hours, minutes, seconds, and microseconds:--
After creating a time object, its attributes can also be printed separately. 

from datetime import time
 
Time = time(11, 34, 56)
 
print("hour =", Time.hour)
print("minute =", Time.minute)
print("second =", Time.second)
print("microsecond =", Time.microsecond)
-----------------------------------------------------------------------------------------------------------------------------

3)Convert Time object to String:--
We can convert time object to string using the isoformat() method.

from datetime import time
 
# Creating Time object
Time = time(12,24,36,1212)
 
# Converting Time object to string
Str = Time.isoformat()
print("String Representation:", Str)
print(type(Str))
-----------------------------------------------------------------------------------------------------------------------------
                                 DateTime class

The DateTime class contains information on both date and time. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, 
datetime assumes there are exactly 3600*24 seconds in every day.

1)DateTime object representing DateTime in Python :--

# Python program to demonstrate datetime object
 
from datetime import datetime
 
# Initializing constructor
a = datetime(1999, 12, 12)
print(a)
 
# Initializing constructor with time parameters as well
a = datetime(1999, 12, 12, 12, 12, 12, 342380)
print(a)
------------------------------------------------------------------------------------------------------------------------------------

2)Get year, month, hour, minute, and timestamp:--
After creating a DateTime object, its attributes can also be printed separately.

from datetime import datetime
 
a = datetime(1999, 12, 12, 12, 12, 12)
 
print("year =", a.year)
print("month =", a.month)
print("hour =", a.hour)
print("minute =", a.minute)
print("timestamp =", a.timestamp())
----------------------------------------------------------------------------------------------------------------------------------
3)Current date and time:--
You can print the current date and time using the Datetime.now() function. now() function returns the current local date and time. 


from datetime import datetime
 
# Calling now() function
today = datetime.now()
 
print("Current date and time is", today)
-----------------------------------------------------------------------------------------------------------------------------------
4)Convert Python Datetime to String
We can convert Datetime to string in Python using the datetime.strftime and datetime.isoformat methods.

from datetime import datetime as dt
 
# Getting current date and time
now = dt.now()
 
string = dt.isoformat(now)
print(string)
print(type(string))
---------------------------------------------------------------------------------------------------------------------------------
Timedelta class:---
Python timedelta class is used for calculating differences in dates and also can be used for date manipulations in Python. It is one of the easiest ways to perform date manipulations.

1)Add days to datetime object:--

# Timedelta function demonstration
 
from datetime import datetime, timedelta
 
 
# Using current time
ini_time_for_now = datetime.now()
 
# printing initial_date
print("initial_date", str(ini_time_for_now))
 
# Calculating future dates for two years
future_date_after_2yrs = ini_time_for_now + timedelta(days=730)
 
future_date_after_2days = ini_time_for_now + timedelta(days=2)
 
# printing calculated future_dates
print('future_date_after_2yrs:', str(future_date_after_2yrs))
print('future_date_after_2days:', str(future_date_after_2days))
-----------------------------------------------------------------------------------------------------------------------------------
2)Difference between two date and times:--
Date and Time difference can also be found using this class.

# Timedelta function demonstration
from datetime import datetime, timedelta
 
# Using current time
ini_time_for_now = datetime.now()
 
# printing initial_date
print("initial_date", str(ini_time_for_now))
 
# Some another datetime
new_final_time = ini_time_for_now + \timedelta(days=2)
 
# printing new final_date
print("new_final_time", str(new_final_time))
 
 
# printing calculated past_dates
print('Time difference:', str(new_final_time - ini_time_for_now))
--------------------------------------------------------------------------------------------------------------------------------
Format Datetime:---
Formatting Datetime can be very necessary as the date representation may differe from place to place. Like in some countries it can be yyyy-mm-dd and in other country it can be 
dd-mm-yyyy. To format Python Datetime strptime and strftime functions can be used.

1)Python Datetime strftime:---
strftime() method converts the given date, time or datetime object to the a string representation of the given format.

from datetime import datetime as dt
 
# Getting current date and time
now = dt.now()
print("Without formatting", now)
 
# Example 1
s = now.strftime("%A %m %-Y")
print('\nExample 1:', s)
 
# Example 2
s = now.strftime("%a %-m %y")
print('\nExample 2:', s)
 
# Example 3
s = now.strftime("%-I %p %S")
print('\nExample 3:', s)
 
# Example 4
s = now.strftime("%H:%M:%S")
print('\nExample 4:', s)
---------------------------------------------------------------------------------------------------------------------------------------------

Handling Python DateTime timezone:------------
Timezones in DateTime can be used in the case where one might want to display time according to the timezone of a specific region. This can be done using the pytz module of Python. 
This module serves the date-time conversion functionalities and helps users serving international client bases.

from datetime import datetime
from pytz import timezone
 
format = "%Y-%m-%d %H:%M:%S %Z%z"
 
# Current time in UTC
now_utc = datetime.now(timezone('UTC'))
print(now_utc.strftime(format))
 
timezones = ['Asia/Kolkata', 'Europe/Kiev', 'America/New_York']
 
for tzone in timezones:
 
# Convert to Asia/Kolkata time zone
    now_asia = now_utc.astimezone(timezone(tzone))
    print(now_asia.strftime(format))










Exception handling:
	Exception is the base class for all the exceptions in Python.

	Try and Except Statement – Catching Exceptions
		Try and except statements are used to catch and handle exceptions in Python. 
		Statements that can raise exceptions are kept inside the try clause and the statements that handle the exception are written inside except clause.
			Ex:
				a = [1, 2, 3]
				try:
					print (a[1])
					print (a[4])
				except:
					print("An error occured")
				
		
	Catching Specific Exception:
	A try statement can have more than one except clause, to specify handlers for different exceptions. Please note that at most one handler will be executed

			try:
				# statement(s)
			except IndexError:
				# statement(s)
			except ValueError:
				# statement(s)


	Try with Else Clause:
	In Python we can also use the else clause on the try-except block which must be present after all the except clauses. 
	The code enters the else block only if the try clause does not raise an exception.

	Finally Keyword in Python:
	Python provides a keyword finally, which is always executed after the try and except blocks.
	The final block always executes after normal termination of try block or after try block terminates due to some exception

			try:
				# Some Code.... 

			except:
				# optional block
				# Handling of exception (if required)

			else:
				# execute if no exception

			finally:
				# Some code .....(always executed)		



	Raising Exception:
	The raise statement allows the programmer to force a specific exception to occur. The sole argument in raise indicates the exception to be raised.
	This must be either an exception instance or an exception class (a class that derives from Exception).



	Exception handling errors:
	-Attribute errors				Raised id object accessing a member which is not available
	-File not found errors			Raisedif file is not available
	-Index error					Raised if index to sequence is out of bound
	-KeyError						Raised if non-existent key requested for set or dictionary
	-Name error						Raised if non-exixtant identifier used
	-Type error 					Raised when wrong type of parameter is sent to a function
	-Value error					Raised when parameter has invalid value
	-Zero division error			Raised when division is done by zero





Regular expressions:
	A Regular Expression (RegEx) is a sequence of characters that defines a search pattern.
	It can detect the presence or absence of a text by matching with a particular pattern, and also can split a pattern into one or more sub-patterns.
	Python provides a re(regular expression) module that supports the use of regex in Python. 
	Its primary function is to offer a search, where it takes a regular expression and a string.
	 Regular expressions may contain
		 -MetaCharacters
		 -Special Sequences
		 -regex module (functions)
		 
		 
	MetaCharacters:
		\(Backslash)	:	It is used to drop the special meaning of character following it
		[](sqare braces):	Sqarebrackets specifies set of charecters you wish to match
		^(Caret)		:	Matches the beginning
		$(Doller) 		:	Matches the end
		.(Period) 		:	Matches any character except newline
		|(Alternation)	:	Means OR (Matches with any of the characters separated by it.
		?(question mark):	Matches zero or one occurrence of the pattern left to it.
		*(star)			:	Matches zero or more occurrences of the pattern left to it.
		+(plus)			:	matches one or more occurrences of the pattern left to it.
		{}(braces)		:	Indicate the number of occurrences of a preceding regex to match.
		()(group)		:	Enclose a group of Regex
		
	Special sequences:
		\A - Matches if the specified characters are at the start of a string.
		\b - Matches if the specified characters are at the beginning or end of a word.
		\B - Opposite of \b. Matches if the specified characters are not at the beginning or end of a word.
		\d - Matches any decimal digit. Equivalent to [0-9]
		\D - Matches any non-decimal digit. Equivalent to [^0-9]
		\s - Matches where a string contains any whitespace character. Equivalent to [ \t\n\r\f\v].
		\S - Matches where a string contains any non-whitespace character. Equivalent to [^ \t\n\r\f\v].
		\w - Matches any alphanumeric character (digits and alphabets). Equivalent to [a-zA-Z0-9_]. By the way, underscore _ is also considered an alphanumeric character.
		\W - Matches any non-alphanumeric character. Equivalent to [^a-zA-Z0-9_]
		\Z - Matches if the specified characters are at the end of a string.
		
	regex module:
		re.findall()	The re.findall() method returns a list of strings containing all matches.
		re.split()		The re.split method splits the string where there is a match and returns a list of strings where the splits have occurred.
		re.sub()		The method returns a string where matched occurrences are replaced with the content of replace variable.
		re.subn()		The re.subn() is similar to re.sub() except it returns a tuple of 2 items containing the new string and the number of substitutions made.
		re.search()		The re.search() method takes two arguments: a pattern and a string. The method looks for the first location where the RegEx pattern produces a match with the string.
		re.escape() 	The re.escape return string with all non-alphanumerics backslashed, this is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it.










 



 								  
															  
															  






















	
	

	
	

   
   
   
   
   

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			